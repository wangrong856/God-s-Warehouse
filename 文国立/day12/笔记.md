# 计算属性

#### 基础使用

> 一个数据，依赖另一些数据计算而来 的结果

```
//页面加载时，第一次执行  赋初始值
//依赖数据发生变化  再次执行(自动重新计算返回的值)
//data属性和computed属性都是变量 --不能重名
computed:{
    '计算属性名'(){
        return '值'  //必须有return
    }
}
```

作业：computed 求两个数的和 显示在页面上

#### 缓存

> 计算属性是基于它们的依赖项的值结果进行缓存的，只要依赖的变量不变，都直接从缓存中取结果

- 计算属性 执行会把结果(return 的值)放到缓存中
- 依赖项不变，多次调用都是从缓存中取值
- 依赖项改变，函数会**自动重新执行**--并缓存新的值

```

<template>
  <div>
    <p>{{ reverseMessage }}</p>
    <p>{{ reverseMessage }}</p>
    <p>{{ reverseMessage }}</p>

    <p>{{ getMessage() }}</p>
    <p>{{ getMessage() }}</p>
    <p>{{ getMessage() }}</p>
  </div>
</template>

<script>
export default {
  data() {
    return {
      msg: 'hello word',
    }
  },
  computed: {
    // 变量
    reverseMessage() {
      console.log('计算属性执行了')
      return this.msg.split('').reverse().join('')
    },
  },

  methods: {
    getMessage() {
      console.log('methods执行了')
      return this.msg.split('').reverse().join('')
    },
  },
}
</script>

<style scoped></style>

```

#### 完整写法

> 计算属性也是变量，如果想要直接赋值，需要使用完整写法

语法：

```
computed: {
    '属性名':{
      set(值){

      },
      get(){
        return '值'
      }
    }
 }
```

代码

```
<template>
  <div>
    <span>姓名</span>
    <input type="text" v-model="fullName" />
  </div>
</template>

<script>
export default {
  computed: {
    fullName: {
      // 给fullName赋值的时候触发set方法  （文本框写入内容）
      set(v) {
        console.log(v)
      },
      // 使用fullName的值的时候触发get方法
      get() {
        return '无名'
      },
    },
  },
}
</script>
```

作业  ：computed的完整写法写全选反选

# 侦听器

#### 基础使用

> 可以侦听data/computed属性值的改变

语法：

```
watch:{
    变量名(newVal,oldVal){
      // 变量名对应的值改变 这里自动触发
    }
  }
```

代码

```
<template>
  <div>
    <input type="text" v-model="name" />
  </div>
</template>

<script>
export default {
  data() {
    return {
      name: '',
    }
  },
  watch: {
    /* 变量名(newVal,oldVal){
      // 变量名对应的值改变 这里自动触发
    } */

    name(newVal, oldVal) {
      // newVal 当前最新值, oldVal 旧值
      console.log(newVal, oldVal)
    },
  },
}
</script>
```

作业：watch  求两个数的和 显示在页面上

#### 深度侦听和立即执行

> 侦听复杂类型，或者立即执行侦听函数

语法:

```
watch: {
    属性名: {
      immediate: true, //立即执行
      deep: true, //侦听复杂类型
      handler(newVal, oldVal) {},
    },
  },
```



# mixins

> 混入(mixins)分发vue组件中的可复用的功能，**一个混入对象可以包含任意组件选项**(data,computed,methods...)，当组件使用混入对象时，所有混入对象的选项将被混合进入该组件本身的选项

#### 基本使用

![混入基本使用](.\混入基本使用.png)

问题:

多个组件都引入该混入，一个组件中改动了mixin中的数据，另一个引入了mixin的组件会受到影响吗？

不会

**不同组件的混入是相互独立的**

#### 全局混入

> 在任何组件中可以直接使用

main.js

```
import { mixins } from './mixins'
Vue.mixin(mixins)
```

mya.vue

```
<template>
  <div>
    <ul>
      <li v-for="(item, index) in arr" :key="index" @click="del(index)">
        {{ item }}
      </li>
    </ul>
    <button @click="add">添加</button>
  </div>
</template>

<script>
export default {
  data() {
    return { msg: 'world' }
  },

  created() {},
}
</script>

<style scoped></style>

```

**总结**

- 全局混入和局部混入没有任何区别（不推荐）