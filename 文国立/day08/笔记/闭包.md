## 3.严格模式

### 3.1什么是严格模式

JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript变体的一种方式，即在严格的条件下运行 JS 代码。

严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。

严格模式对正常的 JavaScript 语义做了一些更改： 

1.消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。

2.消除代码运行的一些不安全之处，保证代码运行的安全。

3.提高编译器效率，增加运行速度。

4.禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class,enum,export, extends, import, super 不能做变量名

### 3.2开启严格模式

严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。

- 情况一 :为脚本开启严格模式

  - 有的 script 脚本是严格模式，有的 script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他
    script 脚本文件。

    ```js
    (function (){
      //在当前的这个自调用函数中有开启严格模式，当前函数之外还是普通模式
    　　　　"use strict";
           var num = 10;
    　　　　function fn() {}
    })();
    //或者 
    <script>
      　"use strict"; //当前script标签开启了严格模式
    </script>
    <script>
      			//当前script标签未开启严格模式
    </script>
    ```

- 情况二: 为函数开启严格模式

  - 要给某个函数开启严格模式，需要把“use strict”;  (或 'use strict'; ) 声明放在函数体所有语句之前。

    ```js
    function fn(){
    　　"use strict";
    　　return "123";
    } 
    //当前fn函数开启了严格模式
    ```

### 3.3严格模式中的变化

严格模式对 Javascript 的语法和行为，都做了一些改变。

```js
'use strict'
num = 10 
console.log(num)//严格模式后使用未声明的变量
--------------------------------------------------------------------------------
var num2 = 1;
delete num2;//严格模式不允许删除变量
--------------------------------------------------------------------------------
function fn() {
 console.log(this); // 严格模式下全局作用域中函数中的 this 是 undefined
}
fn();  
---------------------------------------------------------------------------------
function Star() {
	 this.sex = '男';
}
// Star();严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错.
var ldh = new Star();
console.log(ldh.sex);
----------------------------------------------------------------------------------
setTimeout(function() {
  console.log(this); //严格模式下，定时器 this 还是指向 window
}, 2000);  
```

[更多严格模式要求参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)



## 4.垃圾回收机制

####  4.1什么是垃圾回收机制？** 

垃圾回收机制(Garbage Collection) 简称 GC 

JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。 

正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题 

但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况 

不再用到的内存，没有及时释放，就叫做内存泄漏 

#### 4.2.内存的生命周期** 



![垃圾](C:\Users\54004\Desktop\笔记\images\垃圾.png)



JS环境中分配的内存, 一般有如下生命周期： 

\1. 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 

\2. 内存使用：即读写内存，也就是使用变量、函数等 

\3. 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 

\4. 说明： 

 全局变量一般不会回收(关闭页面回收)； 

 一般情况下局部变量的值, 不用了, 会被自动回收掉

#### 4.3.垃圾回收算法说明

所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉 

下面介绍两种常见的浏览器垃圾回收算法: 引用计数法 和 标记清除法 

 **引用计数** 

IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。 

算法： 

\1. 跟踪记录每个值被引用的次数。 

\2. 如果这个值的被引用了一次，那么就记录次数1 

\3. 多次引用会累加。 

\4. 如果减少一个引用就减1。 

\5. 如果引用次数是0 ，则释放内存。 

**引用计数** 

```
const person = { 

age: 18, 

name: '星星老师' 

} 

const p = person 

person = 1 

p = null 
```



由上面可以看出，引用计数算法是个简单有效的算法。 

但它却存在一个致命的问题：**嵌套引用**。 

如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露

**引用计数** 

```
function fn() { 

let o1 = {} 

let o2 = {} 

o1.a = o2 

o2.a = o1 

return '引用计数无法回收' 

} 

fn() 
```



因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露

#### 4.4 JS垃圾回收机制 

**3.****垃圾回收算法说明** 

所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉 

下面介绍两种常见的浏览器垃圾回收算法: 引用计数法 和 标记清除法 

 **标记清除法** 

现代的浏览器已经不再使用引用计数算法了。 

现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。 

核心： 

\1. 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 

\2. 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。 

\3. 那些无法由根部出发触及到的对象被标记为不再使用，稍后进 行回收。 

 **标记清除法** 

标记所有的引用

![标记清除法](.\images\标记清除法.png)



 

**标记清除** 

```
function fn() { 

let o1 = {} 

let o2 = {} 

o1.a = o2 

o2.a = o1 

return '引用计数无法回收' 

} 
fn() 
```

根部已经访问不到，所以自动清除

## 5.闭包

### 5.1变量的作用域复习

变量根据作用域的不同分为两种：全局变量和局部变量。

1. 函数内部可以使用全局变量。
2. 函数外部不可以使用局部变量。
3. 当函数执行完毕，本作用域内的局部变量会销毁。

### 5.2什么是闭包

闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。 

![](images/img3.png)

### 5.3闭包的作用

作用：延伸变量的作用范围。

```js
 function fn() {
   var num = 10;
   function fun() {
       console.log(num);
 	}
    return fun;
 }
var f = fn();
f();
```

### 5.4闭包的案例

1. 利用闭包的方式得到当前li 的索引号

```js
for (var i = 0; i < lis.length; i++) {
// 利用for循环创建了4个立即执行函数
// 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量
(function(i) {
    lis[i].onclick = function() {
      console.log(i);
    }
 })(i);
}
```

2. 闭包应用-3秒钟之后,打印所有li元素的内容

```js
 for (var i = 0; i < lis.length; i++) {
   (function(i) {
     setTimeout(function() {
     console.log(lis[i].innerHTML);
     }, 3000)
   })(i);
}
```

3. 闭包应用-计算打车价格 

```js
/*需求分析
打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格
如果有拥堵情况,总价格多收取10块钱拥堵费*/

 var car = (function() {
     var start = 13; // 起步价  局部变量
     var total = 0; // 总价  局部变量
     return {
       // 正常的总价
       price: function(n) {
         if (n <= 3) {
           total = start;
         } else {
           total = start + (n - 3) * 5
         }
         return total;
       },
       // 拥堵之后的费用
       yd: function(flag) {
         return flag ? total + 10 : total;
       }
	}
 })();
console.log(car.price(5)); // 23
console.log(car.yd(true)); // 33
```

### 5.5案例

```js
 var name = "The Window";
   var object = {
     name: "My Object",
     getNameFunc: function() {
     return function() {
     return this.name;
     };
   }
 };
console.log(object.getNameFunc()())
-----------------------------------------------------------------------------------
var name = "The Window";　　
  var object = {　　　　
    name: "My Object",
    getNameFunc: function() {
    var that = this;
    return function() {
    return that.name;
    };
  }
};
console.log(object.getNameFunc()())
       
```

