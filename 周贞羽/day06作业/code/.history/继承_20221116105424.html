<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*   function Chinese() {
              this.name = 'zs'
              this.age = 12
              this.sex = '男'
              this.tfColor = '黑色'
              this.sing = function () {
                console.log('sing')
              }
              this.xx = 'xx'
            }

            function Englist() {
              this.name = 'ls'
              this.age = 12
              this.sex = '男'
              this.tfColor = '黑色'
              this.sing = function () {
                console.log('sing')
              }
              this.yy = 'yy'
            } */

      /*
      call() 可以调用函数
      改变this指向 call(this,x,y,z)
      */
      // function fn(x, y) {
      //   console.log(this)
      //   console.log(x + y)
      // }
      // var o = {
      //   name: 'zs',
      // }
      // fn.call(o, 1, 3) //调用了函数  this指向对象o

      // 子构造函数继承父构造函数中的成员
      // 1：定义一个父构造函数
      // 2 定义一个子构造函数
      // 3子构造函数继承父构造函数中的成员  call

      // 父构造函数
      function Father(uname, age) {
        // this父构造函数的对象实例
        this.uname = uname
        this.age = age
      }
      // 子构造函数
      // function Son(uname, age, score) {
      //   // 继承父的属性
      //   Father.call(this, uname, age)
      //   // this子构造函数的对象实例
      //   this.score = score
      // }
      // var s = new Son('刘德华', 34, 100)
      // console.log(s)

      // 第2种 借用原型对象继承
      Father.prototype.money = function () {
        console.log(1000000)
      }

      function Son(uname, age, score) {
        // this子构造函数的对象实例
        this.score = score
      }
      // 这样直接赋值有问题
      // 修改了子原型对象  父原型对象也会跟着一起修改
      // Son.prototype = Father.prototype

      Son.prototype = new Father('ls', 23)
      Son.constructor = Son
    </script>
  </body>
</html>
